'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _Type2 = require('./Type');

var _Type3 = _interopRequireDefault(_Type2);

var _ObjectTypeProperty = require('./ObjectTypeProperty');

var _ObjectTypeProperty2 = _interopRequireDefault(_ObjectTypeProperty);

var _ObjectTypeIndexer = require('./ObjectTypeIndexer');

var _ObjectTypeIndexer2 = _interopRequireDefault(_ObjectTypeIndexer);

var _ObjectTypeCallProperty = require('./ObjectTypeCallProperty');

var _ObjectTypeCallProperty2 = _interopRequireDefault(_ObjectTypeCallProperty);

var _getErrorMessage = require('../getErrorMessage');

var _getErrorMessage2 = _interopRequireDefault(_getErrorMessage);

var _cyclic = require('../cyclic');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var ObjectType = function (_Type) {
  _inherits(ObjectType, _Type);

  function ObjectType() {
    var _ref;

    var _temp, _this, _ret;

    _classCallCheck(this, ObjectType);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = ObjectType.__proto__ || Object.getPrototypeOf(ObjectType)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'ObjectType', _this.properties = [], _this.indexers = [], _this.callProperties = [], _this.exact = false, _temp), _possibleConstructorReturn(_this, _ret);
  }

  _createClass(ObjectType, [{
    key: 'getProperty',


    /**
     * Get a property with the given name, or undefined if it does not exist.
     */
    value: function getProperty(key) {
      var properties = this.properties;
      var length = properties.length;

      for (var i = 0; i < length; i++) {
        var property = properties[i];
        if (property.key === key) {
          return property;
        }
      }
      return this.getIndexer(key);
    }

    /**
     * Determine whether a property with the given name exists.
     */

  }, {
    key: 'hasProperty',
    value: function hasProperty(key) {
      var properties = this.properties;
      var length = properties.length;

      for (var i = 0; i < length; i++) {
        var property = properties[i];
        if (property.key === key) {
          return true;
        }
      }
      return this.hasIndexer(key);
    }

    /**
     * Get an indexer with which matches the given key type.
     */

  }, {
    key: 'getIndexer',
    value: function getIndexer(key) {
      var indexers = this.indexers;
      var length = indexers.length;

      for (var i = 0; i < length; i++) {
        var indexer = indexers[i];
        if (indexer.acceptsKey(key)) {
          return indexer;
        }
      }
    }

    /**
     * Determine whether an indexer exists which matches the given key type.
     */

  }, {
    key: 'hasIndexer',
    value: function hasIndexer(key) {
      var indexers = this.indexers;
      var length = indexers.length;

      for (var i = 0; i < length; i++) {
        var indexer = indexers[i];
        if (indexer.acceptsKey(key)) {
          return true;
        }
      }
      return false;
    }
  }, {
    key: 'collectErrors',
    value: function collectErrors(validation, path, input) {
      if (input === null) {
        validation.addError(path, this, (0, _getErrorMessage2.default)('ERR_EXPECT_OBJECT'));
        return true;
      }

      var hasCallProperties = this.callProperties.length > 0;

      if (hasCallProperties) {
        if (!acceptsCallProperties(this, input)) {
          validation.addError(path, this, (0, _getErrorMessage2.default)('ERR_EXPECT_CALLABLE'));
        }
      } else if ((typeof input === 'undefined' ? 'undefined' : _typeof(input)) !== 'object') {
        validation.addError(path, this, (0, _getErrorMessage2.default)('ERR_EXPECT_OBJECT'));
        return true;
      }
      if ((0, _cyclic.inValidationCycle)(this, input)) {
        return false;
      }
      (0, _cyclic.startValidationCycle)(this, input);

      var result = void 0;

      if (this.indexers.length > 0) {
        result = collectErrorsWithIndexers(this, validation, path, input);
      } else if (this.exact) {
        result = collectErrorsExact(this, validation, path, input);
      } else {
        result = collectErrorsWithoutIndexers(this, validation, path, input);
      }
      (0, _cyclic.endValidationCycle)(this, input);
      return result;
    }
  }, {
    key: 'accepts',
    value: function accepts(input) {
      if (input === null) {
        return false;
      }
      var hasCallProperties = this.callProperties.length > 0;

      if (hasCallProperties) {
        if (!acceptsCallProperties(this, input)) {
          return false;
        }
      } else if ((typeof input === 'undefined' ? 'undefined' : _typeof(input)) !== 'object') {
        return false;
      }
      if ((0, _cyclic.inValidationCycle)(this, input)) {
        return true;
      }
      (0, _cyclic.startValidationCycle)(this, input);

      var result = void 0;
      if (this.indexers.length > 0) {
        result = acceptsWithIndexers(this, input);
      } else if (this.exact) {
        result = acceptsExact(this, input);
      } else {
        result = acceptsWithoutIndexers(this, input);
      }
      (0, _cyclic.endValidationCycle)(this, input);
      return result;
    }
  }, {
    key: 'acceptsType',
    value: function acceptsType(input) {
      if (!(input instanceof ObjectType)) {
        return false;
      }
      var hasCallProperties = this.callProperties.length > 0;

      if (hasCallProperties && !acceptsTypeCallProperties(this, input)) {
        return false;
      }

      if (this.indexers.length > 0) {
        return acceptsTypeWithIndexers(this, input);
      } else {
        return acceptsTypeWithoutIndexers(this, input);
      }
    }
  }, {
    key: 'toString',
    value: function toString() {
      var callProperties = this.callProperties,
          properties = this.properties,
          indexers = this.indexers;

      if ((0, _cyclic.inToStringCycle)(this)) {
        return '$Cycle<Object>';
      }
      (0, _cyclic.startToStringCycle)(this);
      var body = [];
      for (var i = 0; i < callProperties.length; i++) {
        body.push(callProperties[i].toString());
      }
      for (var _i = 0; _i < properties.length; _i++) {
        body.push(properties[_i].toString());
      }
      for (var _i2 = 0; _i2 < indexers.length; _i2++) {
        body.push(indexers[_i2].toString());
      }
      (0, _cyclic.endToStringCycle)(this);
      if (this.exact) {
        return '{|\n' + indent(body.join('\n')) + '\n|}';
      } else {
        return '{\n' + indent(body.join('\n')) + '\n}';
      }
    }
  }, {
    key: 'toJSON',
    value: function toJSON() {
      return {
        typeName: this.typeName,
        callProperties: this.callProperties,
        properties: this.properties,
        indexers: this.indexers,
        exact: this.exact
      };
    }
  }]);

  return ObjectType;
}(_Type3.default);

exports.default = ObjectType;


function acceptsCallProperties(type, input) {
  if (typeof input !== 'function') {
    return false;
  }
  var callProperties = type.callProperties;

  for (var i = 0; i < callProperties.length; i++) {
    var callProperty = callProperties[i];
    if (callProperty.accepts(input)) {
      return true;
    }
  }
  return false;
}

function acceptsTypeCallProperties(type, input) {
  var callProperties = type.callProperties;

  var inputCallProperties = input.callProperties;
  loop: for (var i = 0; i < callProperties.length; i++) {
    var callProperty = callProperties[i];

    for (var j = 0; j < inputCallProperties.length; j++) {
      var inputCallProperty = inputCallProperties[j];
      if (callProperty.acceptsType(inputCallProperty)) {
        continue loop;
      }
    }
    // If we got this far, nothing accepted.
    return false;
  }
  return true;
}

function acceptsWithIndexers(type, input) {
  var properties = type.properties,
      indexers = type.indexers;

  var seen = [];
  for (var i = 0; i < properties.length; i++) {
    var property = properties[i];
    if (!property.accepts(input)) {
      return false;
    }
    seen.push(property.key);
  }
  loop: for (var key in input) {
    if (seen.indexOf(key) !== -1) {
      continue;
    }
    var value = input[key];
    for (var _i3 = 0; _i3 < indexers.length; _i3++) {
      var indexer = indexers[_i3];
      if (indexer.acceptsKey(key) && indexer.acceptsValue(value)) {
        continue loop;
      }
    }

    // if we got this far the key / value did not accepts any indexers.
    return false;
  }
  return true;
}

function acceptsTypeWithIndexers(type, input) {
  var indexers = type.indexers,
      properties = type.properties;

  var inputIndexers = input.indexers;
  var inputProperties = input.properties;
  loop: for (var i = 0; i < properties.length; i++) {
    var property = properties[i];
    for (var j = 0; j < inputProperties.length; j++) {
      var inputProperty = inputProperties[j];
      if (inputProperty.key === property.key) {
        if (property.acceptsType(inputProperty)) {
          continue loop;
        } else {
          return false;
        }
      }
    }
  }
  loop: for (var _i4 = 0; _i4 < indexers.length; _i4++) {
    var indexer = indexers[_i4];
    for (var _j = 0; _j < inputIndexers.length; _j++) {
      var inputIndexer = inputIndexers[_j];
      if (indexer.acceptsType(inputIndexer)) {
        continue loop;
      }
    }
    // if we got this far, nothing accepted
    return false;
  }
  return true;
}

function acceptsWithoutIndexers(type, input) {
  var properties = type.properties;

  for (var i = 0; i < properties.length; i++) {
    var property = properties[i];
    if (!property.accepts(input)) {
      return false;
    }
  }
  return true;
}

function acceptsExact(type, input) {
  var properties = type.properties;
  var length = properties.length;

  loop: for (var key in input) {
    // eslint-disable-line guard-for-in
    for (var i = 0; i < length; i++) {
      var property = properties[i];
      if (property.key === key) {
        if (!property.accepts(input)) {
          return false;
        }
        continue loop;
      }
    }
    // if we got this far the property does not exist in the object.
    return false;
  }
  return true;
}

function acceptsTypeWithoutIndexers(type, input) {
  var properties = type.properties;

  var inputProperties = input.properties;
  loop: for (var i = 0; i < properties.length; i++) {
    var property = properties[i];
    for (var j = 0; j < inputProperties.length; j++) {
      var inputProperty = inputProperties[j];
      if (inputProperty.key === property.key) {
        if (property.acceptsType(inputProperty)) {
          continue loop;
        } else {
          return false;
        }
      }
    }
    return false;
  }
  return true;
}

function collectErrorsWithIndexers(type, validation, path, input) {
  var properties = type.properties,
      indexers = type.indexers;

  var seen = [];
  var hasErrors = false;
  for (var i = 0; i < properties.length; i++) {
    var property = properties[i];
    if (property.collectErrors(validation, path, input)) {
      hasErrors = true;
    }
    seen.push(property.key);
  }
  loop: for (var key in input) {
    if (seen.indexOf(key) !== -1) {
      continue;
    }
    var value = input[key];
    for (var _i5 = 0; _i5 < indexers.length; _i5++) {
      var indexer = indexers[_i5];
      if (indexer.acceptsKey(key) && indexer.acceptsValue(value)) {
        continue loop;
      }
    }

    // if we got this far the key / value was not accepted by any indexers.
    validation.addError(path.concat(key), type, (0, _getErrorMessage2.default)('ERR_NO_INDEXER'));
    hasErrors = true;
  }
  return hasErrors;
}

function collectErrorsWithoutIndexers(type, validation, path, input) {
  var properties = type.properties;

  var hasErrors = false;
  for (var i = 0; i < properties.length; i++) {
    var property = properties[i];
    if (property.collectErrors(validation, path, input)) {
      hasErrors = true;
    }
  }
  return hasErrors;
}

function collectErrorsExact(type, validation, path, input) {
  var properties = type.properties;
  var length = properties.length;

  var hasErrors = false;
  loop: for (var key in input) {
    // eslint-disable-line guard-for-in
    for (var i = 0; i < length; i++) {
      var property = properties[i];
      if (property.key === key) {
        if (property.collectErrors(validation, path, input)) {
          hasErrors = true;
        }
        continue loop;
      }
    }
    // if we got this far the property does not exist in the object.
    validation.addError(path, type, (0, _getErrorMessage2.default)('ERR_UNKNOWN_KEY', key));
    hasErrors = true;
  }
  return hasErrors;
}

function indent(input) {
  var lines = input.split('\n');
  var length = lines.length;

  for (var i = 0; i < length; i++) {
    lines[i] = '  ' + lines[i];
  }
  return lines.join('\n');
}