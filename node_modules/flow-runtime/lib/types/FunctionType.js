'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _Type2 = require('./Type');

var _Type3 = _interopRequireDefault(_Type2);

var _FunctionTypeParam = require('./FunctionTypeParam');

var _FunctionTypeParam2 = _interopRequireDefault(_FunctionTypeParam);

var _FunctionTypeRestParam = require('./FunctionTypeRestParam');

var _FunctionTypeRestParam2 = _interopRequireDefault(_FunctionTypeRestParam);

var _getErrorMessage = require('../getErrorMessage');

var _getErrorMessage2 = _interopRequireDefault(_getErrorMessage);

var _symbols = require('../symbols');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var FunctionType = function (_Type) {
  _inherits(FunctionType, _Type);

  function FunctionType() {
    var _ref;

    var _temp, _this, _ret;

    _classCallCheck(this, FunctionType);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = FunctionType.__proto__ || Object.getPrototypeOf(FunctionType)).call.apply(_ref, [this].concat(args))), _this), _this.typeName = 'FunctionType', _this.params = [], _temp), _possibleConstructorReturn(_this, _ret);
  }

  _createClass(FunctionType, [{
    key: 'collectErrors',
    value: function collectErrors(validation, path, input) {
      if (typeof input !== 'function') {
        validation.addError(path, this, (0, _getErrorMessage2.default)('ERR_EXPECT_FUNCTION'));
        return true;
      }
      var annotation = input[_symbols.TypeSymbol];
      if (annotation) {
        var returnType = this.returnType,
            params = this.params;

        var hasErrors = false;
        for (var i = 0; i < params.length; i++) {
          var param = params[i];
          var annotationParam = annotation.params[i];
          if (!annotationParam && !param.optional) {
            validation.addError(path, this, (0, _getErrorMessage2.default)('ERR_EXPECT_ARGUMENT', param.name, param.type.toString()));
            hasErrors = true;
          } else if (!param.acceptsType(annotationParam)) {
            validation.addError(path, this, (0, _getErrorMessage2.default)('ERR_EXPECT_ARGUMENT', param.name, param.type.toString()));
            hasErrors = true;
          }
        }
        if (!returnType.acceptsType(annotation.returnType)) {
          validation.addError(path, this, (0, _getErrorMessage2.default)('ERR_EXPECT_RETURN', returnType.toString()));
          hasErrors = true;
        }
        return hasErrors;
      } else {
        // We cannot safely check an unannotated function.
        return false;
      }
    }
  }, {
    key: 'accepts',
    value: function accepts(input) {
      if (typeof input !== 'function') {
        return false;
      }
      var params = this.params;

      var annotation = input[_symbols.TypeSymbol];
      if (annotation) {
        var returnType = this.returnType,
            _params = this.params;

        for (var i = 0; i < _params.length; i++) {
          var param = _params[i];
          var annotationParam = annotation.params[i];
          if (!annotationParam && !param.optional) {
            return false;
          } else if (!param.acceptsType(annotationParam)) {
            return false;
          }
        }
        if (!returnType.acceptsType(annotation.returnType)) {
          return false;
        }
        return true;
      } else if (params.length > input.length) {
        // function might not have enough parameters,
        // see how many are really required.
        var needed = 0;
        for (var _i = 0; _i < params.length; _i++) {
          var _param = params[_i];
          if (!_param.optional) {
            needed++;
          }
        }
        if (needed > input.length) {
          return false;
        }
      }
      return true;
    }
  }, {
    key: 'acceptsType',
    value: function acceptsType(input) {
      if (!(input instanceof FunctionType)) {
        return false;
      }
      var returnType = this.returnType;
      var inputReturnType = input.returnType;
      if (!returnType.acceptsType(inputReturnType)) {
        return false;
      }
      var params = this.params;
      var inputParams = input.params;
      if (inputParams.length < params.length) {
        return false;
      }
      for (var i = 0; i < params.length; i++) {
        var param = params[i];
        var inputParam = inputParams[i];
        if (!param.acceptsType(inputParam)) {
          return false;
        }
      }
      return true;
    }
  }, {
    key: 'acceptsParams',
    value: function acceptsParams() {
      var params = this.params,
          rest = this.rest;

      var paramsLength = params.length;

      for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }

      var argsLength = args.length;
      for (var i = 0; i < paramsLength; i++) {
        var param = params[i];
        if (i < argsLength) {
          if (!param.accepts(args[i])) {
            return false;
          }
        } else if (!param.accepts(undefined)) {
          return false;
        }
      }

      if (argsLength > paramsLength && rest) {
        for (var _i2 = paramsLength; _i2 < argsLength; _i2++) {
          if (!rest.accepts(args[_i2])) {
            return false;
          }
        }
      }

      return true;
    }
  }, {
    key: 'acceptsReturn',
    value: function acceptsReturn(input) {
      return this.returnType.accepts(input);
    }
  }, {
    key: 'assertParams',
    value: function assertParams() {
      var params = this.params,
          rest = this.rest;

      var paramsLength = params.length;

      for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        args[_key3] = arguments[_key3];
      }

      var argsLength = args.length;
      for (var i = 0; i < paramsLength; i++) {
        var param = params[i];
        if (i < argsLength) {
          param.assert(args[i]);
        } else {
          param.assert(undefined);
        }
      }

      if (argsLength > paramsLength && rest) {
        for (var _i3 = paramsLength; _i3 < argsLength; _i3++) {
          rest.assert(args[_i3]);
        }
      }

      return args;
    }
  }, {
    key: 'assertReturn',
    value: function assertReturn(input) {
      this.returnType.assert(input);
      return input;
    }
  }, {
    key: 'toString',
    value: function toString() {
      var params = this.params,
          rest = this.rest,
          returnType = this.returnType;

      var args = [];
      for (var i = 0; i < params.length; i++) {
        args.push(params[i].toString());
      }
      if (rest) {
        args.push(rest.toString());
      }
      return '(' + args.join(', ') + ') => ' + returnType.toString();
    }
  }, {
    key: 'toJSON',
    value: function toJSON() {
      return {
        typeName: this.typeName,
        params: this.params,
        rest: this.rest,
        returnType: this.returnType
      };
    }
  }]);

  return FunctionType;
}(_Type3.default);

exports.default = FunctionType;