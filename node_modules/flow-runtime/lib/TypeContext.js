'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _TypeInferrer = require('./TypeInferrer');

var _TypeInferrer2 = _interopRequireDefault(_TypeInferrer);

var _primitiveTypes = require('./primitiveTypes');

var _primitiveTypes2 = _interopRequireDefault(_primitiveTypes);

var _invariant = require('./invariant');

var _invariant2 = _interopRequireDefault(_invariant);

var _Validation = require('./Validation');

var _Validation2 = _interopRequireDefault(_Validation);

var _makeReactPropTypes = require('./makeReactPropTypes');

var _makeReactPropTypes2 = _interopRequireDefault(_makeReactPropTypes);

var _makeJSONError2 = require('./errorReporting/makeJSONError');

var _makeJSONError3 = _interopRequireDefault(_makeJSONError2);

var _makeTypeError2 = require('./errorReporting/makeTypeError');

var _makeTypeError3 = _interopRequireDefault(_makeTypeError2);

var _makeWarningMessage = require('./errorReporting/makeWarningMessage');

var _makeWarningMessage2 = _interopRequireDefault(_makeWarningMessage);

var _types = require('./types');

var _declarations = require('./declarations');

var _symbols = require('./symbols');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var TypeContext = function () {
  function TypeContext() {
    _classCallCheck(this, TypeContext);

    this[_symbols.NameRegistrySymbol] = {};
    this[_symbols.TypePredicateRegistrySymbol] = {};
    this[_symbols.TypeConstructorRegistrySymbol] = new Map();
    this[_symbols.InferrerSymbol] = new _TypeInferrer2.default(this);
    this[_symbols.ModuleRegistrySymbol] = {};
  }

  // Issue 252


  // Issue 252


  // Issue 252


  // Issue 252


  // Issue 252


  // Issue 252


  _createClass(TypeContext, [{
    key: 'makeJSONError',


    // Issue 252
    value: function makeJSONError(validation) {
      return (0, _makeJSONError3.default)(validation);
    }
  }, {
    key: 'makeTypeError',
    value: function makeTypeError(validation) {
      return (0, _makeTypeError3.default)(validation);
    }
  }, {
    key: 'createContext',
    value: function createContext() {
      var context = new TypeContext();
      // Issue 252
      context[_symbols.ParentSymbol] = this;
      return context;
    }
  }, {
    key: 'typeOf',
    value: function typeOf(input) {

      var annotation = this.getAnnotation(input);
      if (annotation) {
        return annotation;
      }
      // Issue 252
      var inferrer = this[_symbols.InferrerSymbol];
      inferrer;

      return inferrer.infer(input);
    }
  }, {
    key: 'get',
    value: function get(name) {
      // Issue 252
      var item = this[_symbols.NameRegistrySymbol][name];
      if (item != null) {
        if (typeof item === 'function') {
          return new item(this);
        } else {
          return item;
        }
      }
      // Issue 252
      var parent = this[_symbols.ParentSymbol];
      if (parent) {
        return parent.get(name);
      }
    }

    /**
     * Get the predicate for a given type name.
     */

  }, {
    key: 'getPredicate',
    value: function getPredicate(name) {
      var item = this[_symbols.TypePredicateRegistrySymbol][name];
      if (item) {
        return item;
      }
      var parent = this[_symbols.ParentSymbol];
      if (parent) {
        return parent.getPredicate(name);
      }
    }

    /**
     * Set the predicate for a given type name.
     * This can be used to customise the behaviour of things like Array
     * detection or allowing Thenables in place of the global Promise.
     */

  }, {
    key: 'setPredicate',
    value: function setPredicate(name, predicate) {
      this[_symbols.TypePredicateRegistrySymbol][name] = predicate;
    }

    /**
     * Check the given value against the named predicate.
     * Returns false if no such predicate exists.
     */

  }, {
    key: 'checkPredicate',
    value: function checkPredicate(name, input) {
      var predicate = this.getPredicate(name);
      if (predicate) {
        return predicate(input);
      } else {
        return false;
      }
    }

    /**
     * Returns a decorator for a function or object with the given type.
     */

  }, {
    key: 'decorate',
    value: function decorate(type) {
      var _this = this;

      return function (input, propertyName, descriptor) {
        if (descriptor && typeof propertyName === 'string') {
          if (typeof descriptor.get === 'function' || typeof descriptor.set === 'function') {
            return descriptor; // @todo decorate getters/setters
          } else {
            return {
              enumerable: true,
              writable: true,
              configurable: true,
              value: descriptor.value,
              initializer: descriptor.initializer
            };
          }
        } else {
          return _this.annotate(input, type);
        }
      };
    }

    /**
     * Annotates an object or function with the given type.
     */

  }, {
    key: 'annotate',
    value: function annotate(input, type) {
      input[_symbols.TypeSymbol] = type;
      return input;
    }
  }, {
    key: 'getAnnotation',
    value: function getAnnotation(input) {
      if (input !== null && (typeof input === 'undefined' ? 'undefined' : _typeof(input)) === 'object' || typeof input === 'function') {
        // Issue 252
        return input[_symbols.TypeSymbol];
      }
    }
  }, {
    key: 'hasAnnotation',
    value: function hasAnnotation(input) {
      if (input == null) {
        return false;
      } else {
        return input[_symbols.TypeSymbol] ? true : false;
      }
    }
  }, {
    key: 'setAnnotation',
    value: function setAnnotation(input, type) {
      input[_symbols.TypeSymbol] = type;
      return input;
    }
  }, {
    key: 'type',
    value: function type(name, _type) {
      if (typeof _type === 'function') {
        var target = new _types.ParameterizedTypeAlias(this);
        target.name = name;
        target.typeCreator = _type;
        return target;
      } else {
        var _target = new _types.TypeAlias(this);
        _target.name = name;
        _target.type = _type;
        return _target;
      }
    }
  }, {
    key: 'declare',
    value: function declare(name, type) {

      if (name instanceof _declarations.Declaration) {
        type = name;
        name = type.name;
      } else if (name instanceof _types.TypeAlias) {
        type = name;
        name = type.name;
      }
      if (typeof type === 'function') {
        type = this.type(name, type);
      }
      if (type instanceof _declarations.ModuleDeclaration) {
        var moduleRegistry = this[_symbols.ModuleRegistrySymbol];
        if (moduleRegistry[name]) {
          throw new Error('Cannot redeclare module: ' + name);
        }
        moduleRegistry[name] = type;
        return type;
      } else {
        (0, _invariant2.default)(type, 'Type must be supplied to declaration');
        var nameRegistry = this[_symbols.NameRegistrySymbol];

        if (nameRegistry[name]) {
          throw new Error('Cannot redeclare type: ' + name);
        }
        if (type instanceof _declarations.Declaration) {
          nameRegistry[name] = type;
          return type;
        } else if (type instanceof _types.TypeAlias || type instanceof _types.ParameterizedTypeAlias) {
          var target = new _declarations.TypeDeclaration(this);
          target.name = name;
          target.typeAlias = type;
          nameRegistry[name] = target;
          return target;
        } else {
          var _target2 = this.var(name, type);
          nameRegistry[name] = _target2;
          return _target2;
        }
      }
    }
  }, {
    key: 'declarations',
    value: function* declarations() {
      var nameRegistry = this[_symbols.NameRegistrySymbol];
      for (var key in nameRegistry) {
        // eslint-disable-line guard-for-in
        yield [key, nameRegistry[key]];
      }
    }
  }, {
    key: 'modules',
    value: function* modules() {
      var moduleRegistry = this[_symbols.ModuleRegistrySymbol];
      for (var key in moduleRegistry) {
        // eslint-disable-line guard-for-in
        yield moduleRegistry[key];
      }
    }
  }, {
    key: 'import',
    value: function _import(moduleName) {
      var moduleRegistry = this[_symbols.ModuleRegistrySymbol];
      if (moduleRegistry[moduleName]) {
        return moduleRegistry[moduleName];
      }

      var _moduleName$split = moduleName.split('/'),
          _moduleName$split2 = _slicedToArray(_moduleName$split, 1),
          head = _moduleName$split2[0];

      var module = moduleRegistry[head];
      if (module) {
        return module.import(moduleName);
      }
      var parent = this[_symbols.ParentSymbol];
      if (parent) {
        return parent.import(moduleName);
      }
    }
  }, {
    key: 'declareTypeConstructor',
    value: function declareTypeConstructor(_ref) {
      var name = _ref.name,
          impl = _ref.impl,
          typeName = _ref.typeName,
          collectErrors = _ref.collectErrors,
          accepts = _ref.accepts,
          inferTypeParameters = _ref.inferTypeParameters;

      var nameRegistry = this[_symbols.NameRegistrySymbol];

      if (nameRegistry[name]) {
        throw new Error('Cannot redeclare type: ' + name);
      }

      var target = new _types.TypeConstructor(this);
      target.name = name;
      target.typeName = typeName;
      target.impl = impl;
      target.collectErrors = collectErrors;
      target.accepts = accepts;
      target.inferTypeParameters = inferTypeParameters;

      nameRegistry[name] = target;

      if (typeof impl === 'function') {
        // Issue 252
        var handlerRegistry = this[_symbols.TypeConstructorRegistrySymbol];
        handlerRegistry;

        if (handlerRegistry.has(impl)) {
          throw new Error('A type handler already exists for the given implementation.');
        }
        handlerRegistry.set(impl, target);
      }
      return target;
    }
  }, {
    key: 'getTypeConstructor',
    value: function getTypeConstructor(impl) {
      // Issue 252
      var handlerRegistry = this[_symbols.TypeConstructorRegistrySymbol];
      handlerRegistry;

      return handlerRegistry.get(impl);
    }
  }, {
    key: 'null',
    value: function _null() {
      return _primitiveTypes2.default.null;
    }
  }, {
    key: 'nullable',
    value: function nullable(type) {
      var target = new _types.NullableType(this);
      target.type = type;
      return target;
    }
  }, {
    key: 'existential',
    value: function existential() {
      return _primitiveTypes2.default.existential;
    }
  }, {
    key: 'empty',
    value: function empty() {
      return _primitiveTypes2.default.empty;
    }
  }, {
    key: 'any',
    value: function any() {
      return _primitiveTypes2.default.any;
    }
  }, {
    key: 'mixed',
    value: function mixed() {
      return _primitiveTypes2.default.mixed;
    }
  }, {
    key: 'void',
    value: function _void() {
      return _primitiveTypes2.default.void;
    }
  }, {
    key: 'number',
    value: function number(input) {
      if (input !== undefined) {
        var target = new _types.NumericLiteralType(this);
        target.value = input;
        return target;
      } else {
        return _primitiveTypes2.default.number;
      }
    }
  }, {
    key: 'boolean',
    value: function boolean(input) {
      if (input !== undefined) {
        var target = new _types.BooleanLiteralType(this);
        target.value = input;
        return target;
      } else {
        return _primitiveTypes2.default.boolean;
      }
    }
  }, {
    key: 'string',
    value: function string(input) {
      if (input !== undefined) {
        var target = new _types.StringLiteralType(this);
        target.value = input;
        return target;
      } else {
        return _primitiveTypes2.default.string;
      }
    }
  }, {
    key: 'symbol',
    value: function symbol(input) {
      if (input !== undefined) {
        var target = new _types.SymbolLiteralType(this);
        target.value = input;
        return target;
      } else {
        return _primitiveTypes2.default.symbol;
      }
    }
  }, {
    key: 'typeParameter',
    value: function typeParameter(id, bound) {
      var target = new _types.TypeParameter(this);
      target.id = id;
      target.bound = bound;
      return target;
    }
  }, {
    key: 'bindTypeParameters',
    value: function bindTypeParameters(subject) {
      // Issue 252
      var typeParameters = subject[_symbols.TypeParametersSymbol];
      if (typeParameters) {
        var keys = Object.keys(typeParameters);

        for (var _len = arguments.length, typeInstances = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          typeInstances[_key - 1] = arguments[_key];
        }

        var length = Math.min(keys.length, typeInstances.length);
        for (var i = 0; i < length; i++) {
          var typeParam = typeParameters[keys[i]];
          typeParam.bound = typeInstances[i];
        }
      }
      return subject;
    }
  }, {
    key: 'module',
    value: function module(name, body) {
      var target = new _declarations.ModuleDeclaration(this);
      target.name = name;
      var innerContext = this.createContext();
      // Issue 252
      innerContext[_symbols.ParentSymbol] = this;
      // Issue 252
      innerContext[_symbols.CurrentModuleSymbol] = target;

      target.innerContext = innerContext;
      body(innerContext);
      return target;
    }
  }, {
    key: 'moduleExports',
    value: function moduleExports(type) {
      var currentModule = this[_symbols.CurrentModuleSymbol];
      if (!currentModule) {
        throw new Error('Cannot declare module.exports outside of a module.');
      }
      var target = new _declarations.ModuleExportsDeclaration(this);
      target.type = type;
      currentModule.moduleExports = target;
      return target;
    }
  }, {
    key: 'var',
    value: function _var(name, type) {
      var target = new _declarations.VarDeclaration(this);
      target.name = name;
      target.type = type;
      return target;
    }
  }, {
    key: 'class',
    value: function _class(name, head) {
      var target = new _declarations.ClassDeclaration(this);
      if (typeof head === 'function') {
        return target;
      }
      target.name = name;

      for (var _len2 = arguments.length, tail = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
        tail[_key2 - 2] = arguments[_key2];
      }

      tail.unshift(head);
      var length = tail.length;

      var properties = [];
      var body = void 0;

      for (var i = 0; i < length; i++) {
        var item = tail[i];
        if (item instanceof _types.ObjectTypeProperty) {
          properties.push(item);
        } else if (item instanceof _types.ObjectType) {
          (0, _invariant2.default)(!body, 'Class body must only be declared once.');
          body = item;
        } else if (item instanceof _declarations.ExtendsDeclaration) {
          (0, _invariant2.default)(!target.superClass, 'Classes can only have one super class.');
          target.superClass = item;
        } else if (item != null && (typeof item === 'undefined' ? 'undefined' : _typeof(item)) === 'object' && !(item instanceof _types.Type)) {
          for (var propertyName in item) {
            // eslint-disable-line
            properties.push(this.property(propertyName, item[propertyName]));
          }
        } else {
          throw new Error('ClassDeclaration cannot contain the given type directly.');
        }
      }
      if (!body) {
        body = new _types.ObjectType(this);
      }
      if (properties.length) {
        var _body$properties;

        (_body$properties = body.properties).push.apply(_body$properties, properties);
      }
      target.body = body;
      return target;
    }
  }, {
    key: 'extends',
    value: function _extends(subject) {
      var target = new _declarations.ExtendsDeclaration(this);

      for (var _len3 = arguments.length, typeInstances = Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
        typeInstances[_key3 - 1] = arguments[_key3];
      }

      target.type = this.ref.apply(this, [subject].concat(_toConsumableArray(typeInstances)));
      return target;
    }
  }, {
    key: 'fn',
    value: function fn(head) {
      for (var _len4 = arguments.length, tail = Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
        tail[_key4 - 1] = arguments[_key4];
      }

      return this.function.apply(this, [head].concat(tail));
    }
  }, {
    key: 'function',
    value: function _function(head) {
      if (typeof head === 'function') {
        var _target3 = new _types.ParameterizedFunctionType(this);
        _target3.bodyCreator = head;
        return _target3;
      }
      var target = new _types.FunctionType(this);

      for (var _len5 = arguments.length, tail = Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {
        tail[_key5 - 1] = arguments[_key5];
      }

      tail.unshift(head);
      var length = tail.length;

      for (var i = 0; i < length; i++) {
        var item = tail[i];
        if (item instanceof _types.FunctionTypeParam) {
          target.params.push(item);
        } else if (item instanceof _types.FunctionTypeRestParam) {
          target.rest = item;
        } else if (item instanceof _types.FunctionTypeReturn) {
          target.returnType = item;
        } else {
          throw new Error('FunctionType cannot contain the given type directly.');
        }
      }
      if (!target.returnType) {
        target.returnType = this.any();
      }
      return target;
    }
  }, {
    key: 'param',
    value: function param(name, type) {
      var optional = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

      var target = new _types.FunctionTypeParam(this);
      target.name = name;
      target.type = type;
      target.optional = optional;
      return target;
    }
  }, {
    key: 'rest',
    value: function rest(name, type) {
      var target = new _types.FunctionTypeRestParam(this);
      target.name = name;
      target.type = type;
      return target;
    }
  }, {
    key: 'return',
    value: function _return(type) {
      var target = new _types.FunctionTypeReturn(this);
      target.type = type;
      return target;
    }
  }, {
    key: 'generator',
    value: function generator(yieldType, returnType, nextType) {
      var target = new _types.GeneratorType(this);
      target.yieldType = yieldType;
      target.returnType = returnType || this.any();
      target.nextType = nextType || this.any();
      return target;
    }
  }, {
    key: 'object',
    value: function object(head) {
      var target = new _types.ObjectType(this);
      if (head != null && (typeof head === 'undefined' ? 'undefined' : _typeof(head)) === 'object' && !(head instanceof _types.Type)) {
        for (var propertyName in head) {
          // eslint-disable-line
          target.properties.push(this.property(propertyName, head[propertyName]));
        }
      } else {
        var body = void 0;

        for (var _len6 = arguments.length, tail = Array(_len6 > 1 ? _len6 - 1 : 0), _key6 = 1; _key6 < _len6; _key6++) {
          tail[_key6 - 1] = arguments[_key6];
        }

        if (head) {
          body = [head].concat(_toConsumableArray(tail));
        } else {
          body = tail;
        }
        var _body = body,
            length = _body.length;

        for (var i = 0; i < length; i++) {
          var item = body[i];
          if (item instanceof _types.ObjectTypeProperty) {
            target.properties.push(item);
          } else if (item instanceof _types.ObjectTypeIndexer) {
            target.indexers.push(item);
          } else if (item instanceof _types.ObjectTypeCallProperty) {
            target.callProperties.push(item);
          } else {
            throw new Error('ObjectType cannot contain the given type directly.');
          }
        }
      }
      return target;
    }
  }, {
    key: 'exactObject',
    value: function exactObject(head) {
      for (var _len7 = arguments.length, tail = Array(_len7 > 1 ? _len7 - 1 : 0), _key7 = 1; _key7 < _len7; _key7++) {
        tail[_key7 - 1] = arguments[_key7];
      }

      var object = this.object.apply(this, [head].concat(_toConsumableArray(tail)));
      object.exact = true;
      return object;
    }
  }, {
    key: 'callProperty',
    value: function callProperty(value) {
      var target = new _types.ObjectTypeCallProperty(this);
      target.value = value;
      return target;
    }
  }, {
    key: 'property',
    value: function property(key, value) {
      var optional = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

      var target = new _types.ObjectTypeProperty(this);
      target.key = key;
      if (value instanceof _types.Type) {
        target.value = value;
      } else {
        target.value = this.object(value);
      }
      target.optional = optional;
      return target;
    }
  }, {
    key: 'indexer',
    value: function indexer(id, key, value) {
      var target = new _types.ObjectTypeIndexer(this);
      target.id = id;
      target.key = key;
      target.value = value;
      return target;
    }
  }, {
    key: 'method',
    value: function method(name, head) {
      var target = new _types.ObjectTypeProperty(this);
      target.key = name;

      for (var _len8 = arguments.length, tail = Array(_len8 > 2 ? _len8 - 2 : 0), _key8 = 2; _key8 < _len8; _key8++) {
        tail[_key8 - 2] = arguments[_key8];
      }

      target.value = this.function.apply(this, [head].concat(tail));
      return target;
    }
  }, {
    key: 'tuple',
    value: function tuple() {
      var target = new _types.TupleType(this);

      for (var _len9 = arguments.length, types = Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {
        types[_key9] = arguments[_key9];
      }

      target.types = types;
      return target;
    }
  }, {
    key: 'array',
    value: function array(elementType) {
      var target = new _types.ArrayType(this);
      target.elementType = elementType || this.any();
      return target;
    }
  }, {
    key: 'union',
    value: function union() {
      var target = new _types.UnionType(this);

      for (var _len10 = arguments.length, types = Array(_len10), _key10 = 0; _key10 < _len10; _key10++) {
        types[_key10] = arguments[_key10];
      }

      target.types = types;
      return target;
    }
  }, {
    key: 'intersect',
    value: function intersect() {
      var target = new _types.IntersectionType(this);

      for (var _len11 = arguments.length, types = Array(_len11), _key11 = 0; _key11 < _len11; _key11++) {
        types[_key11] = arguments[_key11];
      }

      target.types = types;
      return target;
    }
  }, {
    key: 'intersection',
    value: function intersection() {
      return this.intersect.apply(this, arguments);
    }
  }, {
    key: 'box',
    value: function box(reveal) {
      var box = new _types.TypeBox(this);
      box.reveal = reveal;
      return box;
    }
  }, {
    key: 'ref',
    value: function ref(subject) {
      var target = void 0;
      if (typeof subject === 'string') {
        // try and eagerly resolve the reference
        target = this.get(subject);
        if (!target) {
          // defer dereferencing for now
          target = new _types.TypeReference(this);
          target.name = subject;
        }
      } else if (typeof subject === 'function') {
        // Issue 252
        var handlerRegistry = this[_symbols.TypeConstructorRegistrySymbol];
        handlerRegistry;

        // see if we have a dedicated TypeConstructor for this.
        target = handlerRegistry.get(subject);

        if (!target) {
          // just use a generic type handler.
          target = new _types.GenericType(this);
          target.impl = subject;
          target.name = subject.name;
        }
      } else if (subject instanceof _types.Type) {
        target = subject;
      } else {
        throw new Error('Could not reference the given type.');
      }

      for (var _len12 = arguments.length, typeInstances = Array(_len12 > 1 ? _len12 - 1 : 0), _key12 = 1; _key12 < _len12; _key12++) {
        typeInstances[_key12 - 1] = arguments[_key12];
      }

      if (typeInstances.length) {
        var _target4;

        (0, _invariant2.default)(typeof target.apply === 'function', 'Cannot apply non-applicable type: ' + target.typeName + '.');
        return (_target4 = target).apply.apply(_target4, _toConsumableArray(typeInstances));
      } else {
        return target;
      }
    }
  }, {
    key: 'validate',
    value: function validate(type, input) {
      var validation = new _Validation2.default(this, input);
      if (typeof type.name === 'string') {
        validation.inputName = type.name;
      }
      type.collectErrors(validation, [], input);
      return validation;
    }
  }, {
    key: 'warn',
    value: function warn(type, input) {
      var validation = this.validate(type, input);
      var message = (0, _makeWarningMessage2.default)(validation);
      if (typeof message === 'string') {
        this.emitWarningMessage(message);
      }
      return input;
    }

    /**
     * Emits a warning message, using `console.warn()` by default.
     */

  }, {
    key: 'emitWarningMessage',
    value: function emitWarningMessage(message) {
      console.warn(message);
    }
  }, {
    key: 'propTypes',
    value: function propTypes(type) {
      return (0, _makeReactPropTypes2.default)(type.unwrap());
    }
  }, {
    key: 'match',
    value: function match() {
      for (var _len13 = arguments.length, args = Array(_len13), _key13 = 0; _key13 < _len13; _key13++) {
        args[_key13] = arguments[_key13];
      }

      var clauses = args.pop();
      if (!Array.isArray(clauses)) {
        throw new Error('Invalid pattern, last argument must be an array.');
      }
      clauses;
      var pattern = this.pattern.apply(this, _toConsumableArray(clauses));
      return pattern.apply(undefined, args);
    }
  }, {
    key: 'pattern',
    value: function pattern() {
      for (var _len14 = arguments.length, clauses = Array(_len14), _key14 = 0; _key14 < _len14; _key14++) {
        clauses[_key14] = arguments[_key14];
      }

      var length = clauses.length;

      var tests = new Array(length);
      for (var i = 0; i < length; i++) {
        var clause = clauses[i];
        var annotation = this.getAnnotation(clause);
        if (!annotation) {
          if (i !== length - 1) {
            throw new Error('Invalid Pattern - found unannotated function in position ' + i + ', default clauses must be last.');
          }
          tests[i] = true;
        } else {
          (0, _invariant2.default)(annotation instanceof _types.FunctionType || annotation instanceof _types.ParameterizedFunctionType, 'Pattern clauses must be annotated functions.');
          tests[i] = annotation;
        }
      }
      return function () {
        for (var _i = 0; _i < tests.length; _i++) {
          var test = tests[_i];
          var _clause = clauses[_i];
          if (test === true) {
            return _clause.apply(undefined, arguments);
          } else if (test.acceptsParams.apply(test, arguments)) {
            return _clause.apply(undefined, arguments);
          }
        }
        var error = new TypeError('Value did not match any of the candidates.');
        error.name = 'RuntimeTypeError';
        throw error;
      };
    }
  }, {
    key: 'refinement',
    value: function refinement(type) {
      var target = new _types.RefinementType(this);
      target.type = type;

      for (var _len15 = arguments.length, constraints = Array(_len15 > 1 ? _len15 - 1 : 0), _key15 = 1; _key15 < _len15; _key15++) {
        constraints[_key15 - 1] = arguments[_key15];
      }

      target.addConstraint.apply(target, _toConsumableArray(constraints));
      return target;
    }
  }]);

  return TypeContext;
}();

exports.default = TypeContext;